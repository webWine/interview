<!-- 引自:https://juejin.cn/post/6844903744518389768#heading-3 -->
# 什么是模块化?
  将一个复杂的程序按照一定的逻辑拆分成一些独立的js文件,再将这些js文件进行组合后正常完成业务逻辑.那么这些js就能称之为模块
# 模块化的发展进程
  ## 1、多个script引用
    [缺点]:创建大量请求
        script引入需要考虑引入的先后位置
  ## 2、全局函数
    全局声明一些函数,将各个“模块”封装到不同的全局函数中
    [缺点]: 污染全局作用域,可能会造成命名空间污染
  ## 3、命名空间
    将不同的“模块”封装到不同的对象中
    [缺点]: 对象可以被随意修改,也存在污染命名空间的风险
  ## 4、IIFE
    将不同的“模块”封装到不同的自执行中,自执行函数具有封闭的作用域,可以完成作用域隔离
    [缺点]: 多个“模块”相互引用不好完成相互引用  
  ## 5、带参数的IIFE
    在IIFE的基础上传入了参数,解决了模块间相互引用的问题
    [缺点]: 传入了模块,但需要保证传入的模块在传入前就必须已经存在,需要开发者关注依赖的先后引用
# 模块化的好处
  隔离作用域
  避免污染命名空间
  更好的复用性
  高可维护性

# 模块化规范
  ## CommonJS
    [适用范围]:node端,客户端若要使用需借助broswerify库生成新模块
    [特点]:输出的是值的拷贝,在外部修改内部的值的信息后再次获取内部值的信息仍然是初始值
          同步加载,因为CommonJS适用在服务端,在服务器内部可以直接按文件路径相互调用
          缓存结果,模块多次加载时,第二次开始调用时获取的都是第一次调用后创建的结果
          模块的加载顺序就是引用的顺序
          require引入的文件默认是js,如果不是js会按照js-->json-->node的顺序依次查找
          require的参数不同查询的结果也是不同的
            以“/”开头: 表示加载的是一个绝对路径下的地址
            以“./”开头: 表示加载的是一个相对路径下的地址
            除开上面两种以外: 表示引用node内部的模块,例如fs、http等
    [用法]:
        ———CommonJS1:
           导出: exports.xxx = xxx
           导入: require(xxx)
        ———CommonJS2
           导出: module.exports = xxx
           导入: require(xxx)
  ## AMD
    [适用范围]: 双端都可
    [原理]: 通过define定义模块,通过require引入模块
    [特点]: 异步加载
           依赖前置
    [用法]:
           define(“xxx”,function(){})

           require.config({
             baseUrl:'./js',
             paths:{
               a:'./a.js',
               b:'./b.js'
             }
           })
           require([...modules],function(...modules){

           })


  ## CMD
    [适用范围]: 浏览器
    [特点]: 异步加载
           就近依赖,用到才会导入
    [用法]: 和AMD相似,但是不需要外部导入模块,直接在需要使用模块的位置直接导入使用即可

  ## UMD
    [适用范围]: 双端
    [原理]: 匿名函数内兼容了AMD、CommonJS、CMD以及最原始的IIFE的写法,判断哪个存在就用哪个

  ## ESModule
    [适用范围]: 双端
    [特点]: 输出的是值的引用
           静态编译
           不会缓存第一次的结果,每次都会获取新的
           语法层面实现的模块功能

